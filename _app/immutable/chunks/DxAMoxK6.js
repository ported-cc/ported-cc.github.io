const s=(e,n)=>{for(const[t,r]of Object.entries(e))if(r!==void 0)switch(t){case"NULL":return null;case"BOOL":return!!r;case"N":return u(r);case"B":return c(r);case"S":return i(r);case"L":return a(r);case"M":return N(r);case"NS":return new Set(r.map(o=>u(o)));case"BS":return new Set(r.map(c));case"SS":return new Set(r.map(i));default:throw new Error(`Unsupported type passed: ${t}`)}throw new Error(`No value defined: ${JSON.stringify(e)}`)},u=(e,n)=>{const t=Number(e),r=[Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY];if((t>Number.MAX_SAFE_INTEGER||t<Number.MIN_SAFE_INTEGER)&&!r.includes(t))if(typeof BigInt=="function")try{return BigInt(e)}catch{throw new Error(`${e} can't be converted to BigInt. Set options.wrapNumbers to get string value.`)}else throw new Error(`${e} is outside SAFE_INTEGER bounds. Set options.wrapNumbers to get string value.`);return t},i=e=>e,c=e=>e,a=(e,n)=>e.map(t=>s(t)),N=(e,n)=>Object.entries(e).reduce((t,[r,o])=>(t[r]=s(o),t),{}),E=(e,n)=>s({M:e});export{E as u};
